// Package bird provides BIRD configuration generation and management.
package bird

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// SessionConfig represents the configuration for a BGP session.
type SessionConfig struct {
	Name            string   // Protocol name: dn42_<asn>_<suffix>
	Description     string   // Human-readable description
	Interface       string   // Network interface name
	ASN             uint32   // Remote AS number
	IPv4            string   // Remote IPv4 address (for neighbor)
	IPv6            string   // Remote IPv6 address (for neighbor)
	IPv6LinkLocal   string   // Link-local IPv6 address
	Extensions      []string // BGP extensions: mp-bgp, extended-nexthop
	Policy          string   // Policy: normal, direct, transit
	IsMultiprotocol bool     // MP-BGP enabled
	IsExtNH         bool     // Extended Next-Hop enabled
}

// ConfigGenerator generates BIRD configuration files.
type ConfigGenerator struct {
	configDir    string
	sessionDir   string
	templateIPv6 *template.Template
}

// NewConfigGenerator creates a new BIRD config generator.
func NewConfigGenerator(configDir string) (*ConfigGenerator, error) {
	sessionDir := filepath.Join(configDir, "peers")

	// Ensure session directory exists
	if err := os.MkdirAll(sessionDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create session dir: %w", err)
	}

	tmpl, err := template.New("bgp6").Parse(bgpTemplateIPv6)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	return &ConfigGenerator{
		configDir:    configDir,
		sessionDir:   sessionDir,
		templateIPv6: tmpl,
	}, nil
}

// GenerateSession generates BIRD configuration for a session.
func (g *ConfigGenerator) GenerateSession(cfg *SessionConfig) error {
	// Check extensions
	cfg.IsMultiprotocol = containsExtension(cfg.Extensions, "mp-bgp")
	cfg.IsExtNH = containsExtension(cfg.Extensions, "extended-nexthop")

	// Determine neighbor address (prefer link-local for IPv6)
	neighborAddr := cfg.IPv6LinkLocal
	if neighborAddr == "" {
		neighborAddr = cfg.IPv6
	}

	// Generate IPv6 session (standard for DN42)
	var buf bytes.Buffer
	data := map[string]interface{}{
		"Name":            cfg.Name,
		"Description":     cfg.Description,
		"LocalASN":        4242420216, // Local ASN (hardcoded for now)
		"RemoteASN":       cfg.ASN,
		"NeighborAddr":    neighborAddr,
		"Interface":       cfg.Interface,
		"IsMultiprotocol": cfg.IsMultiprotocol,
		"IsExtNH":         cfg.IsExtNH,
		"Policy":          cfg.Policy,
	}

	if err := g.templateIPv6.Execute(&buf, data); err != nil {
		return fmt.Errorf("template execution failed: %w", err)
	}

	// Write to file
	filename := filepath.Join(g.sessionDir, fmt.Sprintf("%s.conf", cfg.Name))
	if err := os.WriteFile(filename, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	return nil
}

// RemoveSession removes the BIRD configuration for a session.
func (g *ConfigGenerator) RemoveSession(name string) error {
	filename := filepath.Join(g.sessionDir, fmt.Sprintf("%s.conf", name))
	if err := os.Remove(filename); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove config: %w", err)
	}
	return nil
}

// containsExtension checks if an extension is in the list.
func containsExtension(extensions []string, ext string) bool {
	for _, e := range extensions {
		if strings.EqualFold(e, ext) {
			return true
		}
	}
	return false
}

// bgpTemplateIPv6 is the BIRD 3 template for IPv6 BGP sessions.
const bgpTemplateIPv6 = `# {{.Description}}
# Auto-generated by moenet-agent

protocol bgp {{.Name}} from dn42_peer {
    neighbor {{.NeighborAddr}} % '{{.Interface}}' as {{.RemoteASN}};
    description "{{.Description}}";
    {{- if .IsMultiprotocol}}
    
    ipv4 {
        import filter dn42_import_filter;
        export filter dn42_export_filter;
        {{- if .IsExtNH}}
        extended next hop on;
        {{- end}}
    };
    {{- end}}
    
    ipv6 {
        import filter dn42_import_filter;
        export filter dn42_export_filter;
    };
}
`
